/*
 * Created by Tristan Scott [tscott14+git@proton.me]
 * June 3, 2024
 *
 * An ADT for storing values of type `T` in a 3D grid.
 */

use std::fmt::Debug;

use crate::utils::{
    position::position::{ChunkPosition, GlobalPosition},
    range::Rangei32,
};

const CHUNK_SIZE: usize = crate::utils::position::units::UnitSizes::CHUNK as usize;

/// A buffer for storing values of type `T` in a 3D grid.
#[derive(Copy, Clone, Default)]
pub struct ChunkBuffer<T: Copy + Default>(pub [[[T; CHUNK_SIZE]; CHUNK_SIZE]; CHUNK_SIZE]);

impl<T: Copy + Default> ChunkBuffer<T> {
    /// Creates a new `Buffer` from a function.
    pub fn from_fn(f: impl Fn(GlobalPosition) -> T) -> Self {
        ChunkBuffer::<()>::default()
            .iter()
            .fold(Self::default(), |mut buffer, (block_pos, _)| {
                buffer.set(block_pos, &f(block_pos));
                buffer
            })
    }

    /// Sets the value at the given `GlobalPosition` to the given value.
    pub fn set(&mut self, position: GlobalPosition, value: &T) {
        let (x, y, z) = position.into();
        assert!(Rangei32::from((0, CHUNK_SIZE as i32)).contains(x));
        assert!(Rangei32::from((0, CHUNK_SIZE as i32)).contains(y));
        assert!(Rangei32::from((0, CHUNK_SIZE as i32)).contains(z));
        self.0[z as usize][x as usize][y as usize] = *value;
    }

    /// Returns the value at the given `GlobalPosition`.
    pub fn get(&self, position: GlobalPosition) -> &T {
        let (_, intrachunk) = position.into();
        let (ix, iy, iz) = intrachunk.into();
        assert!(Rangei32::from((0, CHUNK_SIZE as i32)).contains(ix));
        assert!(Rangei32::from((0, CHUNK_SIZE as i32)).contains(iy));
        assert!(Rangei32::from((0, CHUNK_SIZE as i32)).contains(iz));
        &self.0[iz as usize][ix as usize][iy as usize]
    }

    /// Fills the `Buffer` with the given value.
    pub fn fill(&mut self, value: &T) {
        ChunkBuffer::<()>::default()
            .iter()
            .for_each(|(pos, _)| self.set(pos, value));
    }

    /// Clears the `Buffer` by resetting all values to their default.
    pub fn clear(&mut self) {
        *self = Self::default();
    }
}

/// Converts a 3D array into a `Buffer`.
impl<T: Copy + Default> From<[[[T; CHUNK_SIZE]; CHUNK_SIZE]; CHUNK_SIZE]> for ChunkBuffer<T> {
    fn from(data: [[[T; CHUNK_SIZE]; CHUNK_SIZE]; CHUNK_SIZE]) -> Self {
        Self(data)
    }
}

/// Fills value into a new `Buffer`.
impl<T: Copy + Default> From<T> for ChunkBuffer<T> {
    fn from(value: T) -> Self {
        Self::from([[[value; CHUNK_SIZE]; CHUNK_SIZE]; CHUNK_SIZE])
    }
}

pub struct ChunkBufferIter<'a, T: Copy + Default> {
    buffer: &'a ChunkBuffer<T>,
    index: usize,
}

impl<'a, T: Copy + Default> Iterator for ChunkBufferIter<'a, T> {
    type Item = (GlobalPosition, &'a T);

    fn next(&mut self) -> Option<Self::Item> {
        const CHUNK_VOLUME_SIZE: usize = CHUNK_SIZE * CHUNK_SIZE * CHUNK_SIZE;
        const CHUNK_PLANE_SIZE: usize = CHUNK_SIZE * CHUNK_SIZE;

        if self.index >= CHUNK_VOLUME_SIZE {
            return None;
        }

        let (y_pos, xz_space) = (self.index / CHUNK_PLANE_SIZE, self.index % CHUNK_PLANE_SIZE);
        let (x_pos, z_pos) = (xz_space / CHUNK_SIZE, xz_space % CHUNK_SIZE);

        assert!(Rangei32::from((0, CHUNK_SIZE as i32)).contains(x_pos as i32));
        assert!(Rangei32::from((0, CHUNK_SIZE as i32)).contains(y_pos as i32));
        assert!(Rangei32::from((0, CHUNK_SIZE as i32)).contains(z_pos as i32));

        self.index += 1;

        let position = GlobalPosition::from((x_pos as i32, y_pos as i32, z_pos as i32));
        Some((position, &self.buffer.get(position)))
    }
}

impl<T: Copy + Default> ChunkBuffer<T> {
    /// Creates an iterator over the contents of the `Buffer`.
    pub fn iter(&self) -> ChunkBufferIter<'_, T> {
        ChunkBufferIter {
            buffer: self,
            index: 0,
        }
    }
}

impl<T: Copy + Debug + Default> Debug for ChunkBuffer<T> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        Ok(ChunkBuffer::<()>::default()
            .iter()
            .for_each(|(position, _)| {
                let (x, y, z) = position.into();
                let value = self.get(position);

                match (x, z) {
                    (0, 0) => {
                        writeln!(f, "Chunk Slice at y={}", y).unwrap();
                        write!(f, "{:?} ", value).unwrap();
                    }
                    (_, 3) => writeln!(f, "{:?} ", value).unwrap(),
                    (_, _) => write!(f, "{:?} ", value).unwrap(),
                };
            }))
    }
}
